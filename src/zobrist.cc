/*
    Copyright (C) 2012-2021 Torbjorn Rognes and Frederic Mahe

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    Contact: Torbjorn Rognes <torognes@ifi.uio.no>,
    Department of Informatics, University of Oslo,
    PO Box 1080 Blindern, NO-0316 Oslo, Norway
*/

#include "compairr.h"

uint64_t * zobrist_tab_base = nullptr;
static uint64_t * zobrist_v_base = nullptr;
static uint64_t * zobrist_d_base = nullptr;

void zobrist_init(unsigned int n, unsigned int v_genes, unsigned int d_genes)
{
  /*
    Generate 4n or 20n random 64-bit numbers. They will represent the
    four or twenty different residues in any position (1 to n) of a
    sequence.  They will be XOR'ed together to form the hash of that
    sequence.  The number n should be the length of the longest
    sequence to be hashed including potential additional insertions.

    The number is generated by xor'ing together four shifted
    31-bit random numbers.

    Also make some random values for the V genes and D genes.
  */

  /* allocate memory for table */

  uint64_t numbers = alphabet_size * n + v_genes + d_genes;

  zobrist_tab_base = static_cast<uint64_t *>
    (xmalloc(numbers * sizeof(uint64_t)));

  /* fill table with random 64 bit numbers */

  for (unsigned int i = 0; i < numbers; i++)
    {
      uint64_t z;
      z = arch_random();
      z <<= 16;
      z ^= arch_random();
      z <<= 16;
      z ^= arch_random();
      z <<= 16;
      z ^= arch_random();
      zobrist_tab_base[i] = z;
    }

  zobrist_v_base = zobrist_tab_base + alphabet_size * n;
  zobrist_d_base = zobrist_v_base + v_genes;
}

void zobrist_exit()
{
  xfree(zobrist_tab_base);
}

uint64_t zobrist_hash(unsigned char * s,
                      unsigned int len,
                      int v_gene,
                      int d_gene)
{
  /* compute the Zobrist hash function of sequence s of length len. */
  /* len is the actual number of residues in the sequence */

  uint64_t z = 0;
  if (! opt_ignore_genes)
    z ^= zobrist_v_base[v_gene] ^ zobrist_d_base[d_gene];
  for (unsigned int p = 0; p < len; p++)
    z ^= zobrist_value(p, s[p]);
  return z;
}

uint64_t zobrist_hash_delete_first(unsigned char * s,
                                   unsigned int len,
                                   int v_gene,
                                   int d_gene)
{
  /* compute the Zobrist hash function of sequence s,
     but delete the first base */

  uint64_t z = 0;
  if (! opt_ignore_genes)
    z ^= zobrist_v_base[v_gene] ^ zobrist_d_base[d_gene];
  for(unsigned int p = 1; p < len; p++)
    z ^= zobrist_value(p - 1, s[p]);
  return z;
}

uint64_t zobrist_hash_delete_first_two(unsigned char * s,
                                       unsigned int len,
                                       int v_gene,
                                       int d_gene)
{
  /* compute the Zobrist hash function of sequence s,
     but delete the first two bases */

  uint64_t z = 0;
  if (! opt_ignore_genes)
    z ^= zobrist_v_base[v_gene] ^ zobrist_d_base[d_gene];
  for(unsigned int p = 2; p < len; p++)
    z ^= zobrist_value(p - 2, s[p]);
  return z;
}

uint64_t zobrist_hash_insert_first(unsigned char * s,
                                   unsigned int len,
                                   int v_gene,
                                   int d_gene)
{
  /* compute the Zobrist hash function of sequence s,
     but insert a gap (no value) before the first base */

  uint64_t z = 0;
  if (! opt_ignore_genes)
    z ^= zobrist_v_base[v_gene] ^ zobrist_d_base[d_gene];
  for(unsigned int p = 0; p < len; p++)
    z ^= zobrist_value(p + 1, s[p]);
  return z;
}

uint64_t zobrist_hash_insert_first_two(unsigned char * s,
                                       unsigned int len,
                                       int v_gene,
                                       int d_gene)
{
  /* compute the Zobrist hash function of sequence s,
     but insert two gaps (no value) before the first base */

  uint64_t z = 0;
  if (! opt_ignore_genes)
    z ^= zobrist_v_base[v_gene] ^ zobrist_d_base[d_gene];
  for(unsigned int p = 0; p < len; p++)
    z ^= zobrist_value(p + 2, s[p]);
  return z;
}
